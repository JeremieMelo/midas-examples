tests_isa_dir  := $(basedir)/riscv-mini/tests/isa
timeout_cycles := 10000
include riscv-mini/Makefrag-sim

# Tile Tests
tile_asm_c = $(addprefix Tile., $(addsuffix .cpp.out, $(asm_p_tests)))
$(tile_asm_c): Tile.%.cpp.out: $(tests_isa_dir)/%.hex $(minidir)/Tile.scala \
	$(strober_dir)/strober.scala $(strober_dir)/transforms.scala
	mkdir -p $(logdir) $(resdir)
	cd $(basedir) ; sbt "run TileStrober $(C_FLAGS) +loadmem=$< +max-cycles=$(timeout_cycles) +verbose" \
        | tee $(logdir)/$(notdir $@)
	cp $(gendir)/Tile.$*.sample $(resdir)/
tile_asm_c: $(tile_asm_c)
	@echo; perl -ne 'print " [$$1] $$ARGV \t$$2\n" if /\*{3}(.{8})\*{3}(.*)/' \
	$(addprefix $(logdir)/, $(tile_asm_c)); echo;

tile_asm_v = $(addprefix Tile., $(addsuffix .v.out, $(asm_p_tests)))
$(tile_asm_v): Tile.%.v.out: $(tests_isa_dir)/%.hex $(minidir)/Tile.scala \
	$(strober_dir)/strober.scala $(strober_dir)/transforms.scala
	mkdir -p $(logdir) $(resdir)
	cd $(basedir) ; sbt "run TileStrober $(V_FLAGS) +loadmem=$< +max-cycles=$(timeout_cycles)" \
        | tee $(logdir)/$(notdir $@)
	cp $(gendir)/Tile.$*.sample $(resdir)/
tile_asm_v: $(tile_asm_v)
	@echo; perl -ne 'print " [$$1] $$ARGV \t$$2\n" if /\*{3}(.{8})\*{3}(.*)/' \
	$(addprefix $(logdir)/, $(tile_asm_v)); echo;

# Tile Replay
tile_replay_cpp = $(addprefix Tile., $(addsuffix .cpp.replay, $(asm_p_tests)))
$(tile_replay_cpp): Tile.%.cpp.replay: $(resdir)/Tile.%.sample $(minidir)/Tile.scala
	mkdir -p $(logdir) $(gendir)
	cp $< $(gendir)/
	cd $(basedir) ; sbt "run Tile $(C_FLAGS) +loadmem=$(tests_isa_dir)/$*.hex +max-cycles=$(timeout_cycles)" \
        | tee $(logdir)/$(notdir $@)
tile_replay_cpp: $(tile_replay_cpp)

tile_replay_v = $(addprefix Tile., $(addsuffix .v.replay, $(asm_p_tests)))
$(tile_replay_v): Tile.%.v.replay: $(resdir)/Tile.%.sample $(minidir)/Tile.scala
	mkdir -p $(logdir) $(gendir)
	cp $< $(gendir)/
	cd $(basedir) ; sbt "run Tile $(V_FLAGS) +loadmem=$(tests_isa_dir)/$*.hex +max-cycles=$(timeout_cycles)" \
        | tee $(logdir)/$(notdir $@)
tile_replay_v: $(tile_replay_v)
